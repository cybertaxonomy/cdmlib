			------
			REST API
			------
			------
			2010-11-17
			------


REST API

	The CDM REST API is a {{{http://en.wikipedia.org/wiki/Representational_State_Transfer} RESTful}} interface to resources stored in the {{{./index.html#The_Common_Data_Model_-_CDM}CDM}}. The RESTful architecture allows accessing the various resources like Taxa, Names, References, Media, etc by stable URIs. Due to security constraints and to assure the integration of data, currently only read operations (= HTTP GET) are permitted, {{{https://dev.e-taxonomy.eu/trac/wiki/CdmServerReadWriteRest} write operations}} will be available in the near future.

	The architecture directly exposes domain model entities, i.e. it provides direct serializations of the objects as they are stored in the CDM whereever possible. For the external representations, like LSIDs and TDWG data exchange schema like TCS however using DTOs is unavoidable. The {{{API_Service}API Service}} provides an easy to use way to transfer CDM data to web based clients. The {{{Portal_Service} Portal Service}} is a specialization as needed by {{{http://wp5.e-taxonomy.eu/portal}CDM Dataportal}} that adds some fields like localized representations to the pure CDM entities.

	<Table of Contents>

%{toc|section=1|fromDepth=2|toDepth=4}





* Service Sections

	The CDM REST Services architecture is functionally separated into four different parts:

	* The <<API Service>> a clean RESTful bit, which will expose data in a modular, normalized way. It is a more-or-less one-to-one concordance between URIs and service api methods.
	
	* The <<Portal Service>> which is specially taliored for the needs of dataportals which will primarily display "Species Page". Thus this service will be provide denormalized pages which contain a specific assemblys of information. 
	
	* The <<External Services>> are supporting non CDM applications and services like for example a map generation service, LSID Services.
	
	* The <<Classification Service>> exposes special DTOs which combine data from the <<<TaxonBase>>>, <<<TaxonNode>>> and from the <<<Classification>>> entities.
 
	[]

	Detailed descriptions of the services are available in {{{Service_Descriptions} Service Descriptions}} below.




* Object Boundaries

	Nearly all CDM entities are related to each other more or less dicrectly or indirectly and thus forming a huge object graph. A web services however should only deliver a specific object perhaps with some attached associated objects, so it id crucial to draw the line quite sensible between the objects in question and the full object graph. The CDM Service solves this by selectively initializing CDM entities.

	The primary idea is that the <<API Service>> delivers the requested object with all its *toOne relations. Associated objects of the requested object which are at the many side of the *toMany relations are available through URIs which map the fieldname of the *toMany relation. Transient fields are not serialized except of the <<<titleCache>>> property, this one and serialized and thus initialized for each <<<IdentifiableEntity>>>. The initialization of the <<<titleCache>>> property is performed by the <<<CacheStrategie>>> of the specific cdm class and usually spans multiple associated entities of variable depth of object nesting.

	In contrast the <<Portal Service>>, often adds *toMany relations and transient fields to the requested objects. It even may deliver sub object graphs with a depth of an arbitrary number of levels for specific branches.

	The extend of objects, i.e the initialization depth of CDM entities is documented in {{{Service_Descriptions} Service Descriptions}} below. The extend is explained using a <property path syntax> which indicates the properties and transient getters of a specific CDM entity bean which are being initialized by the service. 

	* Simple (name) - The specified name identifies an individual property of a particular CDM entity bean. The name of the actual getter method is determined using standard !JavaBeans instrospection, so that a property named "xyz" will have a getter method named getXyz() or (for boolean properties only) isXyz(), and a setter method named setXyz().
	
	* Nested (name1.name2.name3) The first name element is used to select a property getter, as for simple references above. The object returned for this property is then consulted, using the same approach, for a property getter for a property named name2, and so on. The property value that is ultimately retrieved or modified is the one identified by the last name element.
	
	* Indexed (name[index]) - The underlying property value is assumed to be an array, or this !JavaBean is assumed to have indexed property getter and setter methods. The appropriate (zero-relative) entry in the array is selected. List objects are now also supported for read/write. You simply need to define a getter that returns the List
	
	* \*toOne-Wildcard ($) This wildcard is used to select all property getters which reference to one associated bean. A wildcard subsequently terminates a 'property path'.
	
	* \*toAny-Wildcard (*) This wildcard is used to select all property getters which reference to one associated bean and to to many associated bean. A wildcard subsequently terminates a 'property path'.
	
	* Combined (name1.name2[index].$) - Combining mapped, nested, and indexed and wildcard references is also supported.
	
	[]
	
	This syntax description partially is lend from {{{http://commons.apache.org/beanutils/commons-beanutils-1.7.0/docs/api/org/apache/commons/beanutils/PropertyUtilsBean.html} Apache Commons BeanUtils}}

	In fact the actual extend of serialized CDM entities may exceed the extend indicated by the property path syntax. This especially happens when a transient getter is to be initialized. Due to potential internal logic in the transient getter it is unpredictable which properties actually are being initialized when only looking at the property path. A common candidate for this is the <<<getTaggedName()>>> property of {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/name/TaxonNameBase.html} TaxonNameBase}}.


	<Developer Hints>:

	The initialization od CDM entities is performed by implementations of the  {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/persistence/dao/BeanInitializer.html} BeanInitializer}} interface. In order to find out more on this topic please refer to {{{https://dev.e-taxonomy.eu/trac/wiki/CdmEntityInitalization} CDM Entity Initialization}}.





* Localization

	In order to provide the client with localized resources all services respect the {{{http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4} Accept-Language HTTP header}}.
	For example the Portal service returns localized representations according to the Language tags supplied in the  Accept-Language HTTP header. 
The service tries finding the best matching representation. If no representation in any preferred language is found the service falls back to return the representation in {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/common/Language.html#DEFAULT()} Default Language}} and if necessary further falls back to return the first representation found if any exists.

	Instances of the folowing CDM classes or subclasses of them potentially have multiple internationalized representations in different languages:

	* <{{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/common/TermBase.html} TermBase}}> - language dependent representation through {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/common/Representation.html} Representation}}; The localized reresentation string is added to the TermBase entities by adding the aaditional field: <representation_L10n>.
 
	* <{{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/description/TextData.html} TextData}}> - language dependent representation through {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/common/MultilanguageText.html} MultilanguageText}}; The localized multilanguage text string is added to the TextData entities by adding the aaditional field: <multilanguageText_L10n>.

	[]

	Localization is handeled a bit differently by various service sections the {{{API_Service} API Service}} just adds the localized representations. The {{{Portal_Service} Portal Service}} which focuses in representation, not only adds the localized representations but also hides the {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/common/Representation.html} Representation}} or {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/model/common/MultilanguageText.html} MultilanguageText}} fields from serialization in order to reduce complexity and to improve performance.

	<Developer Hints>

	Classes involved in Content Localization:
	
	* {{{http://wp5.e-taxonomy.eu/cdmlib/apidocs/eu/etaxonomy/cdm/remote/controller/interceptor/LocaleContextHandlerInterceptor.html} LocaleContextHandlerInterceptor}}
Configuration in: 
	
	* {{{http://dev.e-taxonomy.eu/svn/trunk/cdmlib/cdmlib-remote-webapp/src/main/webapp/WEB-INF/cdmrest-servlet.xml} WEB-INF/cdmrest-servlet.xml}}
 



* Content Negotiation

	There are two ways to demand a special content type:

 	[[1]] by file extension (*.json or *.xml)

 	[[1]] by {{{http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1} Accept HTTP request header}} - Accepted mime types are: <<<application/json>>>, <<<text/xml>>>

	[]
	
	Default: XML

	The CDM REST API primarily trys using the file extension, then the Accept HTTP request header is taken into account. If whether the file extension or not the  Accept HTTP request header specify valid content types the default XML will be used. 

	<Developer Hints>

	Classes involved in Content Negotiation:
	
	* {{{http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html} org.springframework.web.servlet.view.ContentNegotiatingViewResolver}}
	
	[]
	
	Configuration files involved: 
	
	* {{{http://dev.e-taxonomy.eu/svn/trunk/cdmlib/cdmlib-remote-webapp/src/main/webapp/WEB-INF/cdmrest-servlet.xml} WEB-INF/cdmrest-servlet.xml}}
	

	

* Character Encoding

	All data is returned in UTF-8 character encoding.
	
	
	

* Service Descriptions

	The syntax of the mapped service URIs contains the the \{datasource-bean-name\} path element. The available \{datasource-bean-name\}s are taken from a configuration file which is loaded by the CDM-Server during startup. The "datasources.xml" file is loaded by default from the following locations depending on the operation system in which the cdm-server is installed:

	* Linux: <<</opt/cdm-server/.cdmLibrary/datasources.xml>>>

	* Windows: <<<"%PROGRAMFILES%/EDIT CDM-Server/.cdmLibrary/datasources.xml">>>

	[]

	The actual location of the "datasources.xml" can specified and thus be overridden using a specific commandline parameter for EDIT CDM-Server. For more information please refer to the {{{http://wp5.e-taxonomy.eu/cdm-server} CDM Community Server documentation}}.

 
	<NOTE:>

	[[1]] Former versions of the EDIT CDM-Server where using <<<\{USER_HOME\}./cdmLibrary/datasources.xml>>> this is now being only used by the EDIT Taxonomic Editor.

	[[1]] The <<<UpdatableRoutingDataSource>>> is no longer being used by the EDIT CDM-Server.




** API Service

	The are a clean RESTful webservice, which will expose data in a modular, normalized way. 
It is a more-or-less one-to-one concordance between URIs and service api methods. 
Due to its generic architecture the URIs are also generic and follow a common pattern which is repeated in each controller. 
In the following the generic URIs are documented first followed by type specific implementations. The pathelement \{base-type\} is frequently used in generid URIs.

	<Valid Values for \{base-type\} are>:

 	* <<agent>>: Service URIs returning AgentBase or sub type entities.

	* <<description>>: Service URIs returning DescriptionBase or sub type entities. 

	* <<feature>>: Service URIs returning DescriptionBase or sub type entities

	* <<media>>: Service URIs returning Media or sub type entities

	* <<name>>: Service URIs returning TaxonNameBase or sub type entities

	* <<occurrence>>: Service URIs returning SpecimenOrObservationBase or sub type entities

	* <<reference>>: Service URIs returning ReferenceBase or sub type entities

	* <<taxon>>: Service URIs returning TaxonBase or sub type entities

	* <<term>>: Service URIs returning DefinedTermBase or sub type entities

	[]

	Most services are using the <<default initialisation strategy>> which is:
	
----
"$"
----

*** /\{datasource-name\}/\{base-type\}/

	Depending on the URI parameters used, this service returns either a Pager on or a List of the \{base-type\} entities identified by the \{uuid\}. 
The returned \{base-type\} instances are initialized by the <default initialisation strategy>. 

	<URI Parameters to return a Pager>:

	* <pageNumber> the number of the page to be returned, the first page has the pageNumber = 1 - <optional parameter> 

	* <pageSize> the maximum number of entities returned per page (can be null to return all entities in a single page) - <optional parameter> 

	* <type>  Further restricts the type of entities to be returned. If null the type mapped by \{base-type\} is being used. - <optional parameter> 

	[]

	<URI Parameters to return a List>:

	* <start> The offset index from the start of the list. The first entity has the index = 0 - <required parameter> <<The start parameter is used to distinguish between the List and Pager variants!>>

	* <limit> The maximum number of entities returned. - <optional parameter>
	
	* <type> Further restricts the type of entities to return. If null the type mapped by \{base-type\} is being used. - <optional parameter>


*** /\{datasource-name\}/\{base-type\}/name/\{uuid\}

	Get the \{base-type\} entity identified by the \{uuid\}. 

	<Returns:>

	The returned \{base-type\} entity is initialized by the <default initialisation strategy>. 

*** /\{datasource-name\}/\{base-type\}/name/\{uuid\}/annotation

	Get the a Pager on the Annotations for the \{base-type\} entity identified by the \{uuid\}. 

	<Returns:>

	Pager on the Annotations for the \{base-type\} entity identified by the \{uuid\}. 
	The returned \{base-type\} entity are initialized by the <default initialisation strategy>. 



*** /\{datasource-name\}/name/\{name-uuid\}/typeDesignations

	Get the list of TypeDesignationBases of the TaxonNameBase instance identified by the \{name-uuid\}. 

	<Returns:>

	A list of TypeDesignationBase entities which are initialized using the following initialization strategy: 

----
"$",
"citation.authorTeam",
"typifiedNames.taggedName"
----

*** /\{datasource-name\}/taxon/\{taxon-uuid\}/accepted

	Get the set of accepted Taxon entities for a given \{@link TaxonBase\} entity identified by the <code>\{taxon-uuid\}</code>.

	<Returns:>

	A set of Taxon entities which are initialized using the <default initialisation strategy>..

** Portal Service

*** /\{datasource-name\}/portal/name/\{name-uuid\} 

	The TaxonNameBase instance identified by the \{name-uuid\}. 
	The returned TaxonNameBase is initialized by the following strategy 


*** /\{datasource-name\}/portal/name/\{name-uuid\}/descriptions

	Get the list of TaxonNameDescriptions of the Name associated with the TaxonNameBase instance identified by the \{name-uuid\}.

	<Returns:>

	A list of TaxonNameDescription entities which are initialized using the following initialization strategy:

----
"uuid",
"feature",
"elements.$",
"elements.multilanguageText",
"elements.media.representations.parts"
----

*** /\{datasource-name\}/portal/name/\{name-uuid\}/typeDesignations

	Get the list of TypeDesignationBases of the TaxonNameBase instance identified by the \{name-uuid\}. 

	<Returns:>

	A list of TypeDesignationBase entities which are initialized using the following initialization strategy:

----
"citation.authorTeam",
"typeName.$",
"typeName.taggedName",
"typeStatus.representations",
"typeSpecimen.media.representations.parts"
----


*** /\{datasource-name\}/portal/taxon/\{taxon-uuid\}

	Get the TaxonBase instance identified by the \{taxon-uuid\}. 
	The returned Taxon is initialized by the following strategy TAXON_INIT_STRATEGY 
 
----
"*",
"relationsToThisName.fromTaxon.name.taggedName",
"name.$",
"name.taggedName",
"name.rank.representations",
"name.status.type.representations",
"descriptions.elements.$",
"descriptions.elements.area",
"descriptions.elements.area.$",
"descriptions.elements.multilanguageText",
"descriptions.elements.media.representations.parts",
----

*** /\{datasource-name\\}/portal/taxon/find 

	Find Taxa, Synonyms, Common Names by name, either globally or in a specific geographic area. 

	<URI Parameters:>

	* <<query>> the string to query for. Since the wildcard character '*' internally always is appended to the query string, a search always compares the query string with the beginning of a name. - <required parameter>

	* <<treeUuid>> the UUID of a TaxonomicTree to which the search is to be restricted. - <optional parameter>

	* <<areas>> restrict the search to a set of geographic NamedAreas. The parameter currently takes a list of TDWG area labels.  - <optional parameter>

	* <<page>> the number of the page to be returned, the first page has the pageNumber = 1 - <optional parameter>

	* <<pageSize>> the maximum number of entities returned per page (can be null to return all entities in a single page) - <optional parameter>

	* <<doTaxa>> weather to search for instances of Taxon - <optional parameter>

	* <<doSynonyms>> weather to search for instances of Synonym - <optional parameter>

	* <<doTaxaByCommonNames>> for instances of Taxon by a common name used - <optional parameter>
 
	[]

	<Returns:>
	
	A pager on a list of IdentifiableEntitys initialized by the following strategy:

----
"*",
"relationsToThisName.fromTaxon.name.taggedName",
"name.$",
"name.taggedName",
"name.rank.representations",
"name.status.type.representations"
----

*** /\{datasource-name\}/portal/taxon/\{taxon-uuid\}/synonymy

	Get the synonymy for a taxon identified by the \{taxon-uuid\}. The synonymy consists of two parts: The group of homotypic synonyms of the taxon and the heterotypic synonymy groups of the taxon. The synonymy is ordered historically by the type designations and by the publication date of the nomenclatural reference 

	<Returns:>

	A map with to entries which are mapped by the following keys: "homotypicSynonymsByHomotypicGroup", "heterotypicSynonymyGroups", containing lists of Synonyms which are initialized using the following initialization strategy:

----
"synonymRelations.$",
"synonymRelations.synonym.$",
"synonymRelations.synonym.name.taggedName",
"synonymRelations.synonym.name.nomenclaturalReference.inBook.authorTeam",
"synonymRelations.synonym.name.nomenclaturalReference.inJournal",
"synonymRelations.synonym.name.nomenclaturalReference.inProceedings",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.$",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.name.taggedName",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.taxonBases.$",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.taxonBases.name.taggedName",

"name.homotypicalGroup.$",
"name.homotypicalGroup.typifiedNames.$",
"name.homotypicalGroup.typifiedNames.name.taggedName",

"name.homotypicalGroup.typifiedNames.taxonBases.$",
"name.homotypicalGroup.typifiedNames.taxonBases.name.taggedName"
----

*** /\{datasource-name\}/portal/taxon/\{taxon-uuid\}/accepted

	Get the set of accepted Taxon entities for a given \{@link TaxonBase\} entity identified by the <code>\{taxon-uuid\}</code>.

	<Returns:>
	
	A set of Taxon entities which are initialized using the following initialization strategy:

----
"synonymRelations.$",
"synonymRelations.synonym.$",
"synonymRelations.synonym.name.taggedName",
"synonymRelations.synonym.name.nomenclaturalReference.inBook.authorTeam",
"synonymRelations.synonym.name.nomenclaturalReference.inJournal",
"synonymRelations.synonym.name.nomenclaturalReference.inProceedings",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.$",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.name.taggedName",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.taxonBases.$",
"synonymRelations.synonym.name.homotypicalGroup.typifiedNames.taxonBases.name.taggedName",

"name.homotypicalGroup.$",
"name.homotypicalGroup.typifiedNames.$",
"name.homotypicalGroup.typifiedNames.name.taggedName",

"name.homotypicalGroup.typifiedNames.taxonBases.$",
"name.homotypicalGroup.typifiedNames.taxonBases.name.taggedName"
----

***  /\{datasource-name\}/portal/taxon/\{taxon-uuid\}/taxonRelationships 

	Get the list of TaxonRelationships for the given TaxonBase instance identified by the \{taxon-uuid\}. 

	<Returns:>
	
	A list of TaxonRelationship entities which are initialized using the following initialization strategy:

----
"$",
"type.inverseRepresentations",
"fromTaxon.sec.authorTeam",
"fromTaxon.name.taggedName"
----

*** /\{datasource-name\}/portal/taxon/\{taxon-uuid\}/nameRelationships

	Get the list of NameRelationships of the Name associated with the TaxonBase instance identified by the \{taxon-uuid\}. 

	<Returns:>

	A list of NameRelationship entities which are initialized using the following initialization strategy:

----
"$",
"type.inverseRepresentations",
"fromName.taggedName"
----

*** /\{datasource-name\}/portal/taxon/\{taxon-uuid\}/nameTypeDesignations

	Get the list of TypeDesignationBases of the TaxonBase instance identified by the \{taxon-uuid\}. 

	<Returns:>
	
	A list of TypeDesignationBase entities which are initialized using the following initialization strategy:

----
"typeSpecimen.$",
"typeStatus.representations",
"citation.authorTeam",
"typeName.taggedName"
----

*** /\{datasource-name\}/portal/taxon/\{taxon-uuid\}/descriptions

	Get the list of TaxonDescriptions of the Taxon instance identified by the \{taxon-uuid\}. 

	<Returns:>
	
	A list of TaxonDescription entities which are initialized using the following initialization strategy:

----
"$",
"elements.$",
"elements.citation.authorTeam",
"elements.multilanguageText",
"elements.media.representations.parts"
----

*** /\{datasource-name\}/portal/taxon/\{taxon-uuid\}/media/\{mime type list\}/\{size\}[,[widthOrDuration\}][,\{height\}]/

	Get the list of TaxonDescriptions of the Taxon instance identified by the \{taxon-uuid\}. 

	<Usage:>

 	/\{datasource-name\}/portal/taxon/\{taxon-uuid\}/media/\{mime type list\}/\{size\}[,[widthOrDuration\}][,\{height\}]/ 
 
	<Whereas>
	
 	* <<\{mime type list\}>>: a comma separated list of mime types, in the order of preference. The forward slashes contained in the mime types must be replaced by a colon. Regular expressions can be used. Each media associated with this given taxon is being searched whereas the first matching mime type matching a representation always rules. 

	* <<\{size\}>>,<<\{widthOrDuration\}>>,<<\{height\}>>: (not jet implemented) valid values are an integer or the asterisk '*' as a wildcard 

	[]
	
	<Returns:>
	
	A list of Media entities which are initialized using the following initialization strategy:

----
"$",
"elements.$",
"elements.citation.authorTeam",
"elements.multilanguageText",
"elements.media.representations.parts"
----

*** datasource-name\}/portal/taxontree

	Lists all available TaxonomicTrees. 

	<Returns:>
	
	A list of TaxonomicTrees initialized by the following initialization strategy:

----
"reference.authorTeam.titleCache"
----

*** /\{datasource-name\}/portal/taxontree/\{tree-uuid\},\{rank-uuid\}

	Lists all TaxonNodes of the specified TaxonomicTree for a given Rank. If a branch does not contain a TaxonNode with a TaxonName at the given Rank the node associated with the next lower Rank is taken as root node. If the rank is null the absolute root nodes will be returned. 

	<URI elements>: 
	
	* <\{tree-uuid\}> identifies the TaxonomicTree by its UUID. 
	
	* <\{rank-uuid\}> identifies the Rank by its UUID. May be left out. 

	[]

	<Returns:>
	
	A list of TaxonNode entities initialized by the following initialization strategy:

----
"taxon.sec", 
"taxon.name.taggedName"
----

***  /\{datasource-name\}/portal/taxontree/\{tree-uuid\},\{rank- uuid\}/\{taxon-uuid\}

	Lists all child-TaxonNodes of the specified Taxon in the TaxonomicTree. The a given Rank is ignored in this method but for consistency reasons it has been allowed to included it into the URI. 

	<URI elements>: 
	
	* <\{tree-uuid\}> identifies the TaxonomicTree by its UUID. 
	
	* <\{rank-uuid\}> identifies the Rank by its UUID. May be left out. 
	
	* <\{taxon-uuid\}> identifies the Taxon by its UUID. - <required>. 
	
	[]
	
	<Returns:>
	
	A list of TaxonNode entities initialized by the following initialization strategy:

----
"taxon.sec", 
"taxon.name.taggedName"
----

***  /\{datasource-name\}/portal/taxontree/\{tree-uuid\},\{rank-uuid\}/\{taxon-uuid\}/path

	Provides path of TaxonNodes from the base node to the node of the specified taxon. 

	<URI elements>: 
	
	* <\{tree-uuid\}> identifies the TaxonomicTree by its UUID. 
	
	* <\{rank-uuid\}> identifies the Rank by its UUID. May be left out. 
	
	* <\{taxon-uuid\}> identifies the Taxon by its UUID. - <required>. 

	[]

	<Returns:>
	
	A list of TaxonNode entities initialized by the following initialization strategy:

----
"taxon.sec", 
"taxon.name.taggedName"
----

** External Service

*** /\{datasource-name\}/geo/map/distribution/\{taxon-uuid\}

	Assembles and returns URI parameter Strings for the EDIT Map Service. 
The distribution areas for the Taxon instance identified by the \{taxon-uuid\} are found and are translated into an valid URI parameter String. 
Higher level distribiution areas are expanded in order to include all nested sub-areas.