package eu.etaxonomy.cdm.io.cdmprintpub;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import eu.etaxonomy.cdm.api.service.ITaxonNodeService;
import eu.etaxonomy.cdm.common.monitor.IProgressMonitor;
import eu.etaxonomy.cdm.hibernate.HibernateProxyHelper;
import eu.etaxonomy.cdm.io.cdmprintpub.PrintPubDocumentModel.PrintPubPageBreakElement;
import eu.etaxonomy.cdm.io.cdmprintpub.PrintPubDocumentModel.PrintPubParagraphElement;
import eu.etaxonomy.cdm.io.cdmprintpub.PrintPubDocumentModel.PrintPubUnorderedListElement;
import eu.etaxonomy.cdm.io.cdmprintpub.PrintPubDocumentModel.SectionHeader;
import eu.etaxonomy.cdm.io.common.CdmExportBase;
import eu.etaxonomy.cdm.io.common.TaxonNodeOutStreamPartitioner;
import eu.etaxonomy.cdm.io.common.mapping.out.IExportTransformer;
import eu.etaxonomy.cdm.model.common.CdmBase;
import eu.etaxonomy.cdm.model.common.Language;
import eu.etaxonomy.cdm.model.common.LanguageString;
import eu.etaxonomy.cdm.model.description.CommonTaxonName;
import eu.etaxonomy.cdm.model.description.DescriptionElementBase;
import eu.etaxonomy.cdm.model.description.Distribution;
import eu.etaxonomy.cdm.model.description.Feature;
import eu.etaxonomy.cdm.model.description.IndividualsAssociation;
import eu.etaxonomy.cdm.model.description.TaxonDescription;
import eu.etaxonomy.cdm.model.description.TextData;
import eu.etaxonomy.cdm.model.name.TaxonName;
import eu.etaxonomy.cdm.model.taxon.Synonym;
import eu.etaxonomy.cdm.model.taxon.Taxon;
import eu.etaxonomy.cdm.model.taxon.TaxonNode;

@Component
public class PrintPubClassificationExport
        extends CdmExportBase<PrintPubExportConfigurator, PrintPubExportState, IExportTransformer, File> {

    private static final long serialVersionUID = 1L;

    @Autowired
    private ITaxonNodeService taxonNodeService;

    public PrintPubClassificationExport() {
        this.ioName = this.getClass().getSimpleName();
    }

    @Override
    @Transactional(readOnly = true)
    protected void doInvoke(PrintPubExportState state) {
        try {
            IProgressMonitor monitor = state.getConfig().getProgressMonitor();

            // 1. Create the Title Page / Metadata
            handleMetaData(state);

            // 2. Setup the Partitioner
            TaxonNodeOutStreamPartitioner<PrintPubExportState> partitioner = TaxonNodeOutStreamPartitioner.NewInstance(
                    this, state, state.getConfig().getTaxonNodeFilter(), 100, // Batch size
                    monitor, null);

            monitor.subTask("Start partitioning and exporting...");

            // 3. Traverse the tree using the CdmLight pattern
            TaxonNode node = partitioner.next();
            while (node != null) {
                handleTaxonNode(state, node);
                node = partitioner.next();
            }

            // 4. Finalize
            state.getProcessor().createFinalResult();

        } catch (Exception e) {
            state.getResult().addException(e, "Error in PrintPub export: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleMetaData(PrintPubExportState state) {
        state.getProcessor().add(new SectionHeader(state.getConfig().getDocumentTitle(), 1));
        state.getProcessor().add(new PrintPubParagraphElement("Generated by CDM PrintPub Export"));
        state.getProcessor().add(new PrintPubPageBreakElement());
    }

    private void handleTaxonNode(PrintPubExportState state, TaxonNode node) {
        if (node == null || node.getTaxon() == null) {
            return;
        }

        int level = calculateDepth(node);

        // Cap the header level at 6 (Markdown only supports # to ######)
        // Level 1 (Root) -> H2
        // Level 2 -> H3
        int headerLevel = (level < 1) ? 2 : Math.min(level + 1, 6);

        Taxon taxon = HibernateProxyHelper.deproxy(node.getTaxon(), Taxon.class);
        handleTaxon(state, taxon, headerLevel);
    }

    private void handleTaxon(PrintPubExportState state, Taxon taxon, int headerLevel) {
        state.setCurrentTaxon(taxon);

        TaxonName name = HibernateProxyHelper.deproxy(taxon.getName(), TaxonName.class);
        String title = (name != null) ? name.getTitleCache() : taxon.getTitleCache();
        state.getProcessor().add(taxon, new SectionHeader(title, headerLevel));

        if (state.getConfig().isDoSynonyms()) {
            handleSynonyms(state, taxon);
        }

        if (state.getConfig().isDoFactualData()) {
            handleDescriptions(state, taxon);
        }
    }

    private void handleSynonyms(PrintPubExportState state, Taxon taxon) {
        if (!taxon.hasSynonyms()) {
            return;
        }

        PrintPubUnorderedListElement list = new PrintPubUnorderedListElement();
        for (Synonym syn : taxon.getSynonyms()) {
            syn = CdmBase.deproxy(syn);
            String synName = syn.getName() != null ? syn.getName().getTitleCache() : syn.getTitleCache();
            list.addItem("= " + synName);
        }

        if (!list.getItems().isEmpty()) {
            state.getProcessor().add(new PrintPubParagraphElement("**Synonyms:**"));
            state.getProcessor().add(list);
        }
    }

    private void handleDescriptions(PrintPubExportState state, Taxon taxon) {
        Set<TaxonDescription> descriptions = taxon.getDescriptions();

        List<DescriptionElementBase> simpleFacts = new ArrayList<>();
        List<DescriptionElementBase> distributionFacts = new ArrayList<>();
        List<DescriptionElementBase> commonNameFacts = new ArrayList<>();
        List<DescriptionElementBase> specimenFacts = new ArrayList<>();

        // 1. Sort elements into buckets
        for (TaxonDescription desc : descriptions) {
            if (!state.getConfig().isIncludeUnpublishedFacts() && !desc.isPublish()) {
                continue;
            }

            for (DescriptionElementBase element : desc.getElements()) {
                element = CdmBase.deproxy(element);
                Feature feature = element.getFeature();

                if (feature.equals(Feature.COMMON_NAME())) {
                    commonNameFacts.add(element);
                } else if (feature.equals(Feature.DISTRIBUTION())) {
                    distributionFacts.add(element);
                } else if (element instanceof IndividualsAssociation || isSpecimenFeature(feature)) {
                    specimenFacts.add(element);
                } else {
                    // Everything else (TextData, CategoricalData, etc.)
                    simpleFacts.add(element);
                }
            }
        }

        // 2. Process buckets in a specific order for the document
        if (!commonNameFacts.isEmpty()) {
            handleCommonNameFacts(state, commonNameFacts);
        }

        if (!distributionFacts.isEmpty()) {
            handleDistributionFacts(state, distributionFacts);
        }

        if (!simpleFacts.isEmpty()) {
            handleSimpleFacts(state, simpleFacts);
        }

        if (!specimenFacts.isEmpty()) {
            handleSpecimenFacts(state, specimenFacts);
        }
    }

    private void handleCommonNameFacts(PrintPubExportState state, List<DescriptionElementBase> elements) {
        PrintPubUnorderedListElement list = new PrintPubUnorderedListElement();

        for (DescriptionElementBase element : elements) {
            if (element instanceof CommonTaxonName) {
                CommonTaxonName commonName = (CommonTaxonName) element;
                String name = commonName.getName();
                String lang = (commonName.getLanguage() != null) ? " [" + commonName.getLanguage().getLabel() + "]" : "";
                String area = (commonName.getArea() != null) ? " (" + commonName.getArea().getLabel() + ")" : "";

                list.addItem(name + lang + area);
            } else if (element instanceof TextData) {
                 TextData td = (TextData) element;
                 String text = td.getText(Language.DEFAULT());
                 if (text != null) {
                    list.addItem(text);
                 }
            }
        }

        if (!list.getItems().isEmpty()) {
            state.getProcessor().add(new PrintPubParagraphElement("**Common Names:**"));
            state.getProcessor().add(list);
        }
    }

    private void handleDistributionFacts(PrintPubExportState state, List<DescriptionElementBase> elements) {
        StringBuilder distributionText = new StringBuilder();
        boolean first = true;

        for (DescriptionElementBase element : elements) {
            if (element instanceof Distribution) {
                Distribution dist = (Distribution) element;
                if (dist.getArea() != null) {
                    if (!first) {
                        distributionText.append(", ");
                    }
                    distributionText.append(dist.getArea().getLabel());

                    if (dist.getStatus() != null) {
                        distributionText.append(" (").append(dist.getStatus().getLabel()).append(")");
                    }
                    first = false;
                }
            }
        }

        if (distributionText.length() > 0) {
            state.getProcessor().add(new PrintPubParagraphElement("**Distribution:** " + distributionText.toString()));
        }
    }

    private void handleSimpleFacts(PrintPubExportState state, List<DescriptionElementBase> elements) {
        List<Language> fallbackLanguages = new ArrayList<>();
        fallbackLanguages.add(Language.DEFAULT());
        fallbackLanguages.add(Language.ENGLISH());

        for (DescriptionElementBase element : elements) {
            if (element instanceof TextData) {
                TextData textData = (TextData) element;
                LanguageString bestText = textData.getPreferredLanguageString(fallbackLanguages);

                if (bestText != null && bestText.getText() != null && !bestText.getText().isEmpty()) {
                    Feature feature = element.getFeature();
                    String label = (feature != null) ? feature.getLabel() : "Note";
                    state.getProcessor().add(new PrintPubParagraphElement("**" + label + "**: " + bestText.getText()));
                }
            }
        }
    }

    private void handleSpecimenFacts(PrintPubExportState state, List<DescriptionElementBase> elements) {
        PrintPubUnorderedListElement list = new PrintPubUnorderedListElement();

        for (DescriptionElementBase element : elements) {
            if (element instanceof IndividualsAssociation) {
                IndividualsAssociation assoc = (IndividualsAssociation) element;
                if (assoc.getAssociatedSpecimenOrObservation() != null) {
                    String title = assoc.getAssociatedSpecimenOrObservation().getTitleCache();
                    list.addItem(title);
                }
            }
        }

        if (!list.getItems().isEmpty()) {
            state.getProcessor().add(new PrintPubParagraphElement("**Specimens:**"));
            state.getProcessor().add(list);
        }
    }

    private boolean isSpecimenFeature(Feature feature) {
        if (feature == null) {
            return false;
        }
        if (feature.isSupportsIndividualAssociation()) {
            return true;
        }
        return feature.equals(Feature.SPECIMEN()) ||
               feature.equals(Feature.INDIVIDUALS_ASSOCIATION()) ||
               feature.equals(Feature.MATERIALS_EXAMINED()) ||
               feature.equals(Feature.OBSERVATION()) ||
               feature.equals(Feature.OCCURRENCE());
    }

    private int calculateDepth(TaxonNode node) {
        int depth = 1;
        TaxonNode parent = node.getParent();
        while (parent != null) {
            depth++;
            parent = parent.getParent();
        }
        return depth;
    }

    @Override
    protected boolean doCheck(PrintPubExportState state) {
        return state.getConfig().getDestination() != null;
    }

    @Override
    protected boolean isIgnore(PrintPubExportState state) {
        return false;
    }
}